# Enhanced chatbot with improved error handling and responses - NUEVA VERSION MEJORADA
import google.generativeai as genai
from typing import List, Dict, Tuple, Optional, Union, Any
from datetime import datetime
import logging
import json
import re
from sqlalchemy.orm import Session
from sqlalchemy import insert, select, update, and_, func
from app.database import get_db, Product, Cart, User, Category, ChatSession, ChatMessage as DBChatMessage, cart_items
from app.models import Product as ProductModel, Cart as CartModel

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EnhancedInfotecChatbotV2:
    def __init__(self, api_key: str):
        """Inicializar el chatbot mejorado con flujo de conversaci√≥n inteligente"""
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash')
        
        # Informaci√≥n extendida de la empresa
        self.company_info = {
            "nombre": "GRUPO INFOTEC",
            "descripcion": "Empresa l√≠der en tecnolog√≠a y servicios inform√°ticos en Per√∫",
            "especialidades": [
                "Computadoras de escritorio y laptops",
                "Equipos gaming de alta gama", 
                "Componentes PC (procesadores, tarjetas gr√°ficas, memorias)",
                "Monitores y perif√©ricos",
                "Soporte t√©cnico especializado",
                "Servicio t√©cnico autorizado",
                "Mantenimiento preventivo y correctivo"
            ],
            "servicios": [
                "Venta de equipos nuevos",
                "Equipos reacondicionados certificados",
                "Armado de PC personalizado",
                "Instalaci√≥n y configuraci√≥n",
                "Soporte t√©cnico 24/7",
                "Garant√≠a extendida",
                "Financiamiento disponible"
            ]
        }
        
        # Respuestas preparadas para preguntas comunes
        self.prepared_responses = {
            "envio": {
                "patterns": ["env√≠o", "envio", "entrega", "llega", "cu√°ndo llega", "tiempo entrega", "delivery"],
                "response": """üì¶ **Informaci√≥n de Env√≠os:**

üöÄ **Lima Metropolitana:**
‚Ä¢ Entrega en 24-48 horas laborables
‚Ä¢ Gratis por compras mayores a S/150

üöö **Provincias:**
‚Ä¢ 3-5 d√≠as laborables
‚Ä¢ Costo seg√∫n destino (S/15-35)

üíº **Entrega Express:**
‚Ä¢ Mismo d√≠a en Lima (zonas seleccionadas)
‚Ä¢ Costo adicional: S/25

üìç **Recojo en tienda:**
‚Ä¢ Gratis en nuestras 3 tiendas
‚Ä¢ Disponible en 2-4 horas

¬øTe gustar√≠a conocer m√°s detalles sobre alguna opci√≥n de env√≠o?"""
            },
            "otros_modelos": {
                "patterns": ["otros modelos", "otras opciones", "m√°s modelos", "diferentes modelos", "qu√© m√°s tienen"],
                "response": """üîç **¬°Por supuesto! Tenemos una amplia variedad:**

üíª **Categor√≠as disponibles:**
‚Ä¢ Laptops Gaming (ASUS ROG, MSI, HP Omen)
‚Ä¢ Laptops Empresariales (Dell Latitude, HP EliteBook) 
‚Ä¢ Laptops Estudiantiles (Lenovo IdeaPad, ASUS VivoBook)
‚Ä¢ Laptops 2-en-1 (HP Envy x360, Lenovo Yoga)
‚Ä¢ All-in-One (HP, Dell, Lenovo)
‚Ä¢ PCs Gaming personalizadas

üè∑Ô∏è **Rangos de precio:**
‚Ä¢ B√°sicas: S/800 - S/1,500
‚Ä¢ Intermedias: S/1,500 - S/3,000  
‚Ä¢ Premium: S/3,000 - S/8,000+

¬øQu√© tipo espec√≠fico te interesa? Puedo mostrarte opciones seg√∫n tu presupuesto y uso."""
            },
            "garantia": {
                "patterns": ["garant√≠a", "garantia", "garantizada", "cobertura", "servicio t√©cnico"],
                "response": """üõ°Ô∏è **Garant√≠a Grupo INFOTEC:**

‚úÖ **Garant√≠a del fabricante:**
‚Ä¢ 1 a√±o en todas las laptops nuevas
‚Ä¢ 6 meses en equipos reacondicionados

üîß **Servicio t√©cnico especializado:**
‚Ä¢ Diagn√≥stico gratuito
‚Ä¢ T√©cnicos certificados
‚Ä¢ Repuestos originales

üìû **Soporte t√©cnico:**
‚Ä¢ WhatsApp: +51 999-888-777
‚Ä¢ Email: soporte@grupoinfotec.pe
‚Ä¢ Horario: Lun-S√°b 8am-8pm

üí° **Garant√≠a extendida disponible:**
‚Ä¢ +1 a√±o adicional por solo S/99
‚Ä¢ Incluye mantenimiento preventivo

¬øNecesitas m√°s informaci√≥n sobre la garant√≠a?"""
            },
            "financiamiento": {
                "patterns": ["financiamiento", "cuotas", "pagar en partes", "cr√©dito", "facilidades"],
                "response": """üí≥ **Opciones de Financiamiento:**

üè¶ **Tarjetas de cr√©dito:**
‚Ä¢ Hasta 24 cuotas sin intereses*
‚Ä¢ Visa, Mastercard, American Express

üí∞ **Financiamiento directo:**
‚Ä¢ Hasta 12 cuotas con tasa preferencial
‚Ä¢ Sin inicial en compras mayores a S/2,000

üéØ **Promociones especiales:**
‚Ä¢ 3 cuotas sin intereses (cualquier monto)
‚Ä¢ 6 cuotas sin intereses (compras +S/1,500)

üì± **Pago digital:**
‚Ä¢ Yape, Plin, BCP, Interbank
‚Ä¢ Transferencias bancarias

*Aplican t√©rminos y condiciones del banco emisor.

¬øQu√© opci√≥n te conviene m√°s?"""
            }
        }
        
        # Diccionario para mantener las conversaciones por sesi√≥n
        self.session_conversations: Dict[str, List[Dict[str, Any]]] = {}

    def check_prepared_response(self, message: str) -> Optional[str]:
        """Verificar si el mensaje coincide con alguna respuesta preparada"""
        message_lower = message.lower()
        
        for category, info in self.prepared_responses.items():
            for pattern in info["patterns"]:
                if pattern in message_lower:
                    return info["response"]
        
        return None

    def extract_entities(self, message: str) -> Dict[str, Any]:
        """Extraer entidades del mensaje usando regex y IA - MEJORADO"""
        entities: Dict[str, Any] = {
            "_original_message": message  # Guardar mensaje original para contexto
        }
        
        message_lower = message.lower()
        
        # Extraer productos espec√≠ficos
        product_patterns = {
            "laptop": r"laptop|portatil|notebook",
            "pc": r"\bpc\b|computadora|desktop",
            "gaming": r"gaming|gamer|juegos",
            "monitor": r"monitor|pantalla",
            "teclado": r"teclado|keyboard",
            "mouse": r"mouse|raton"
        }
        
        for product, pattern in product_patterns.items():
            if re.search(pattern, message_lower):
                entities["producto"] = product
                break
        
        # Extraer marcas
        brands = ["hp", "dell", "lenovo", "asus", "acer", "msi", "apple", "samsung"]
        for brand in brands:
            if brand in message_lower:
                entities["marca"] = brand
                break
        
        # Extraer presupuesto
        price_match = re.search(r'(?:hasta|m√°ximo|presupuesto|budget)\s*(?:de\s*)?(?:s/\s*)?(\d+)', message_lower)
        if price_match:
            entities["presupuesto"] = int(price_match.group(1))
        
        # Extraer cantidad
        quantity_match = re.search(r'(\d+)\s*(?:unidades?|pcs?|equipos?)', message_lower)
        if quantity_match:
            entities["cantidad"] = int(quantity_match.group(1))
        
        # Detectar uso/caso de uso
        use_cases = {
            "gaming": ["gaming", "gamer", "juegos", "videojuegos", "fps", "minecraft", "fortnite"],
            "universidad": ["universidad", "universitario", "estudios", "carrera", "tesis", "investigaci√≥n"],
            "trabajo": ["trabajo", "oficina", "empresarial", "corporativo", "profesional"],
            "programacion": ["programar", "programaci√≥n", "desarrollo", "c√≥digo", "python", "java"],
            "dise√±o": ["dise√±o", "photoshop", "illustrator", "render", "3d", "gr√°fico"],
            "basico": ["b√°sico", "simple", "internet", "word", "excel", "navegaci√≥n"]
        }
        
        for use_case, keywords in use_cases.items():
            if any(keyword in message_lower for keyword in keywords):
                            entities["uso"] = use_case
            break
          # Detectar intenci√≥n de agregar al carrito
        cart_patterns = ["agregar", "a√±adir", "carrito", "comprar", "llevar", "quiero", "necesito", "agrega", "puedes agregar"]
        if any(pattern in message_lower for pattern in cart_patterns):
            entities["accion"] = "agregar_carrito"
          # Detectar solicitud de especificaciones - MEJORADO
        spec_patterns = ["especificaciones", "specs", "caracter√≠sticas", "detalles", "informaci√≥n detallada", "especificacion", "que especificacion", "qu√© especificaci√≥n"]
        if any(pattern in message_lower for pattern in spec_patterns):
            entities["accion"] = "ver_especificaciones"
        
        # Detectar solicitud de recomendaci√≥n - NUEVO
        recommend_patterns = ["recomiendas", "recomendaci√≥n", "recomendaciones", "cual recomiendas", "qu√© recomiendas", "cual me recomiendas", "que me recomiendas", "cual es mejor", "cu√°l es mejor", "cual eliges", "sugieres"]
        if any(pattern in message_lower for pattern in recommend_patterns):
            entities["accion"] = "recomendar"
        
        # Extraer nombre espec√≠fico de producto mencionado
        self.extract_product_name_from_message(message_lower, entities)
        
        return entities

    def extract_product_name_from_message(self, message_lower: str, entities: Dict[str, Any]) -> None:
        """Extraer nombre espec√≠fico del producto mencionado"""
        # Patrones comunes de productos espec√≠ficos - MEJORADO
        product_patterns = [
            # HP patterns - AMPLIADO
            r"hp\s+pavilion\s+gaming[\s\w]*",
            r"hp\s+pavilion[\s\w]*",
            r"hp\s+15-fc0048la",
            r"hp\s+14-ep0011la",
            r"hp\s+envy\s+x360",
            r"hp\s+omen[\s\w]*",
            
            # Lenovo patterns
            r"lenovo\s+legion\s+5[\s\w]*",
            r"lenovo\s+v15\s+g4\s+amn\s+ryzen\s+5",
            r"lenovo\s+v15\s+g4\s+i3",
            r"lenovo\s+ideapad\s+slim\s+3",
            r"lenovo\s+yoga\s+7",
            r"lenovo\s+ideapad\s+flex\s+5",
            
            # ASUS patterns
            r"asus\s+rog\s+strix\s+g15[\s\w]*",
            r"asus\s+vivobook\s+go\s+15",
            r"asus\s+vivobook\s+15\s+flip",
            
            # Dell patterns
            r"dell\s+inspiron\s+3520"
        ]
        
        for pattern in product_patterns:
            match = re.search(pattern, message_lower)
            if match:
                entities["producto_especifico"] = match.group().strip()
                break

    def should_show_products(self, entities: Dict[str, Any], conversation_history: List[Dict[str, Any]]) -> bool:
        """Determinar si debe buscar y mostrar productos"""
        # Si hay acci√≥n espec√≠fica de ver especificaciones, buscar el producto
        if entities.get("accion") == "ver_especificaciones":
            return True
        
        # Si hay acci√≥n de agregar al carrito, buscar el producto
        if entities.get("accion") == "agregar_carrito":
            return True
        
        # Si menciona un producto espec√≠fico
        if entities.get("producto_especifico"):
            return True
        
        # Si menciona una categor√≠a de producto
        if entities.get("producto"):
            return True
        
        # Si menciona una marca
        if entities.get("marca"):
            return True
        
        # Si menciona presupuesto
        if entities.get("presupuesto"):
            return True
        
        # Si menciona caso de uso espec√≠fico  
        if entities.get("uso"):
            return True
            
        return False
    
    def get_search_query_from_context(self, entities: Dict[str, Any], conversation_history: List[Dict[str, Any]]) -> str:
        """Obtener consulta de b√∫squeda basada en entidades y contexto"""
        search_terms = []
        
        # Agregar producto espec√≠fico si existe
        if entities.get("producto_especifico"):
            return entities["producto_especifico"]
        
        # Agregar categor√≠a de producto
        if entities.get("producto"):
            search_terms.append(entities["producto"])
        
        # Agregar marca
        if entities.get("marca"):
            search_terms.append(entities["marca"])
        
        # Agregar caso de uso
        if entities.get("uso"):
            if entities["uso"] == "gaming":
                search_terms.append("gaming")
            elif entities["uso"] == "universidad":
                        search_terms.append("estudiante")
            elif entities["uso"] == "trabajo":
                search_terms.append("empresarial")
        
        # Si no hay t√©rminos espec√≠ficos, usar t√©rmino gen√©rico
        if not search_terms:
            search_terms.append("laptop")
        
        return " ".join(search_terms)
    
    def search_products(self, db: Session, search_query: str, max_price: Optional[int] = None) -> List[ProductModel]:
        """Buscar productos en la base de datos - MEJORADO"""
        try:
            # Import CRUD function
            from app.crud import search_products as crud_search_products
            
            # Buscar productos usando CRUD
            db_products = crud_search_products(db, search_query, limit=20)
            
            # Convertir a modelos Pydantic con validaciones manuales
            products = []
            count = 0
            
            for db_product in db_products:
                try:
                    # Crear el modelo primero
                    product_model = ProductModel.from_orm(db_product)
                    
                    # Filtrar por stock (ahora que ya es un modelo Pydantic)
                    if product_model.stock_quantity <= 0:
                        continue
                    
                    # Filtrar por precio si se especifica
                    if max_price and product_model.price > max_price:
                        continue
                    
                    products.append(product_model)
                    count += 1
                    
                    if count >= 10:  # M√°ximo 10 productos
                        break
                        
                except Exception as e:
                    logger.warning(f"Error convirtiendo producto: {e}")
                    continue
            
            return products
            
        except Exception as e:
            logger.error(f"Error buscando productos: {e}")
            return []
    
    def find_product_by_name(self, db: Session, product_name: str) -> Optional[ProductModel]:
        """Buscar producto espec√≠fico por nombre - MEJORADO"""
        try:
            logger.info(f"Buscando producto por nombre: '{product_name}'")
            
            # Limpiar y normalizar el nombre del producto
            clean_name = product_name.strip().lower()
            
            # Estrategia 1: Buscar por coincidencia exacta en el nombre
            exact_match = db.query(Product).filter(Product.name.ilike(f"%{clean_name}%")).first()
            if exact_match:
                logger.info(f"Encontrado por coincidencia exacta: {exact_match.name}")
                return ProductModel.from_orm(exact_match)
            
            # Estrategia 2: Buscar por palabras clave individuales
            keywords = [word for word in clean_name.split() if len(word) > 2]
            logger.info(f"Buscando por palabras clave: {keywords}")
            
            if keywords:
                db_query = db.query(Product)
                for keyword in keywords:
                    db_query = db_query.filter(Product.name.ilike(f"%{keyword}%"))
                
                product = db_query.first()
                if product:
                    logger.info(f"Encontrado por palabras clave: {product.name}")
                    return ProductModel.from_orm(product)
            
            # Estrategia 3: Buscar por marcas y modelos espec√≠ficos
            brand_searches = {
                "hp pavilion": "HP Pavilion",
                "lenovo legion": "Legion",
                "asus rog": "ROG",
                "dell inspiron": "Inspiron"
            }
            
            for search_term, db_term in brand_searches.items():
                if search_term in clean_name:
                    product = db.query(Product).filter(Product.name.ilike(f"%{db_term}%")).first()
                    if product:
                        logger.info(f"Encontrado por b√∫squeda de marca: {product.name}")
                        return ProductModel.from_orm(product)
            
            logger.warning(f"No se encontr√≥ producto para: '{product_name}'")
            return None
            
        except Exception as e:
            logger.error(f"Error buscando producto por nombre '{product_name}': {e}")
            return None

    def generate_product_specifications(self, product: ProductModel) -> str:
        """Generar especificaciones detalladas de un producto"""
        spec_response = f"üìã **Especificaciones T√©cnicas - {product.name}**\n\n"
        
        # Precio y disponibilidad
        spec_response += f"üí∞ **Precio:** S/ {product.price:.2f}\n"
        if hasattr(product, 'original_price') and product.original_price and product.original_price > product.price:
            discount = round((1 - product.price / product.original_price) * 100)
            spec_response += f"üè∑Ô∏è **Precio anterior:** S/ {product.original_price:.2f} ({discount}% de descuento)\n"
        
        spec_response += f"üì¶ **Stock:** {product.stock_quantity} unidades disponibles\n"
        spec_response += f"‚≠ê **Calificaci√≥n:** {getattr(product, 'rating', 'N/A')}/5\n\n"
        
        # Marca y modelo
        spec_response += f"üè¢ **Marca:** {product.brand}\n"
        if hasattr(product, 'model') and product.model:
            spec_response += f"üì± **Modelo:** {product.model}\n"
        
        # Descripci√≥n t√©cnica (extraer specs desde el nombre)
        name_lower = product.name.lower()
        
        # Procesador
        if "ryzen 5" in name_lower:
            spec_response += f"‚ö° **Procesador:** AMD Ryzen 5\n"
        elif "ryzen 7" in name_lower:
            spec_response += f"‚ö° **Procesador:** AMD Ryzen 7\n"
        elif "i3" in name_lower:
            spec_response += f"‚ö° **Procesador:** Intel Core i3\n"
        elif "i5" in name_lower:
            spec_response += f"‚ö° **Procesador:** Intel Core i5\n"
        elif "i7" in name_lower:
            spec_response += f"‚ö° **Procesador:** Intel Core i7\n"
        
        # Memoria RAM
        if "8gb" in name_lower:
            spec_response += f"üß† **Memoria RAM:** 8GB\n"
        elif "16gb" in name_lower:
            spec_response += f"üß† **Memoria RAM:** 16GB\n"
        elif "32gb" in name_lower:
            spec_response += f"üß† **Memoria RAM:** 32GB\n"
        
        # Almacenamiento
        if "256gb ssd" in name_lower:
            spec_response += f"üíæ **Almacenamiento:** 256GB SSD\n"
        elif "512gb ssd" in name_lower:
            spec_response += f"üíæ **Almacenamiento:** 512GB SSD\n"
        elif "1tb ssd" in name_lower:
            spec_response += f"üíæ **Almacenamiento:** 1TB SSD\n"
        
        # Pantalla
        if "15.6" in name_lower:
            spec_response += f"üñ•Ô∏è **Pantalla:** 15.6 pulgadas\n"
        elif "14" in name_lower:
            spec_response += f"üñ•Ô∏è **Pantalla:** 14 pulgadas\n"
        
        if "fhd" in name_lower:
            spec_response += f"üì∫ **Resoluci√≥n:** Full HD (1920x1080)\n"
        
        if "t√°ctil" in name_lower or "touch" in name_lower:
            spec_response += f"üëÜ **Pantalla t√°ctil:** S√≠\n"
        
        # Caracter√≠sticas especiales
        if "gaming" in name_lower or "gamer" in name_lower:
            spec_response += f"üéÆ **Gaming:** Optimizada para juegos\n"
        
        if "2 en 1" in name_lower or "2en1" in name_lower:
            spec_response += f"üîÑ **Convertible:** Laptop 2 en 1\n"
        
        # Descripci√≥n adicional        if hasattr(product, 'description') and product.description:
            spec_response += f"\nüìù **Descripci√≥n:**\n{product.description}\n"
        
        spec_response += f"\nüí° **¬øTe interesa este modelo? ¬°Puedo agregarlo a tu carrito!**"
        
        return spec_response

    def add_to_cart(self, db: Session, product_id: int, quantity: int = 1, 
                    user_id: Optional[int] = None, session_id: Optional[str] = None) -> bool:
        """Agregar producto al carrito - MEJORADO"""
        try:
            # Verificar que el producto existe y tiene stock
            product = db.query(Product).filter(Product.id == product_id).first()
            if not product:
                logger.warning(f"Producto {product_id} no encontrado")
                return False
            
            # Convertir a modelo Pydantic para evitar errores de tipado
            try:
                product_model = ProductModel.from_orm(product)
                # Verificar stock disponible usando el modelo Pydantic
                if product_model.stock_quantity < quantity:
                    logger.warning(f"Stock insuficiente. Disponible: {product_model.stock_quantity}, Solicitado: {quantity}")
                    return False
            except Exception as model_error:
                logger.error(f"Error convirtiendo producto a modelo: {model_error}")
                return False
            
            logger.info(f"Agregando producto {product_id} al carrito (cantidad: {quantity})")
            return True
            
        except Exception as e:
            logger.error(f"Error agregando al carrito: {e}")
            return False

    def generate_product_response(self, products: List[ProductModel], use_case: Optional[str] = None) -> str:
        """Generar respuesta con productos - MEJORADO"""
        if not products:
            return "No encontr√© productos que coincidan con tu b√∫squeda. ¬øPodr√≠as ser m√°s espec√≠fico?"
          # Mensaje personalizado seg√∫n el caso de uso
        intro_messages = {
            "gaming": "üéÆ ¬°Perfecto para gaming! Aqu√≠ tienes las mejores opciones:",
            "universidad": "üéì Ideales para tus estudios universitarios:",
            "trabajo": "üíº Excelentes opciones para uso profesional:",
            "programacion": "üë®‚Äçüíª Perfectas para desarrollo y programaci√≥n:",
            "basico": "üíª Opciones ideales para uso b√°sico:",
        }
        
        # Corregir el error de tipado usando una condici√≥n expl√≠cita
        if use_case and use_case in intro_messages:
            intro = intro_messages[use_case]
        else:
            intro = f"Encontr√© {len(products)} opciones que podr√≠an interesarte:"
        
        response = f"{intro}\n\n"
        
        # Mostrar hasta 3 productos principales
        for i, product in enumerate(products[:3]):
            try:
                # Calcular descuento si existe
                discount_info = ""
                if hasattr(product, 'original_price') and product.original_price and product.original_price > product.price:
                    discount = round((1 - product.price / product.original_price) * 100)
                    discount_info = f" üè∑Ô∏è **{discount}% DESC**"
                
                # Stock status
                stock_status = "‚úÖ En stock" if product.stock_quantity > 5 else f"‚ö†Ô∏è Quedan {product.stock_quantity}"
                
                response += f"**{i+1}. {product.name}**\n"
                response += f"üí∞ **S/ {product.price:.2f}**{discount_info}\n"
                response += f"üì¶ {stock_status}\n"
                if hasattr(product, 'rating') and product.rating:
                    response += f"‚≠ê {product.rating}/5\n"
                response += "\n"
                
            except Exception as e:
                logger.warning(f"Error formateando producto {product.id}: {e}")
                continue
        
        # Mensaje de seguimiento
        if len(products) > 3:
            response += f"üí° *Y {len(products) - 3} opciones m√°s disponibles*\n\n"
        
        response += "¬øTe interesa alguna opci√≥n espec√≠fica? ¬°Puedo darte m√°s detalles! üòä"
        
        return response

    def generate_general_response(self, message: str, context_str: str = "") -> str:
        """Generar respuesta general usando IA - MEJORADO con mejor prompt"""
        try:
            # Primero verificar respuestas preparadas
            prepared_response = self.check_prepared_response(message)
            if prepared_response:
                return prepared_response
            
            # Usar IA para respuestas m√°s complejas
            prompt = f"""
            Eres InfoBot, el asistente virtual amigable de GRUPO INFOTEC, empresa peruana l√≠der en tecnolog√≠a.
            
            INFORMACI√ìN DE LA EMPRESA:
            - Nombre: GRUPO INFOTEC
            - Especialidad: Laptops, PCs, componentes, soporte t√©cnico
            - Ubicaci√≥n: Lima, Per√∫
            - Experiencia: +15 a√±os en el mercado
            - Servicios: Venta, soporte 24/7, garant√≠as, financiamiento
            
            INSTRUCCIONES IMPORTANTES:
            1. Responde de manera amigable, profesional y concisa (m√°ximo 200 palabras)
            2. Usa emojis para hacer las respuestas m√°s amigables
            3. Si preguntan sobre productos, sugiere que pueden mostrar opciones espec√≠ficas
            4. Si preguntan sobre env√≠os, garant√≠as o financiamiento, da informaci√≥n √∫til
            5. Promociona los servicios de GRUPO INFOTEC cuando sea relevante
            6. NUNCA inventes informaci√≥n t√©cnica espec√≠fica
            
            CONTEXTO DE CONVERSACI√ìN: {context_str}
            
            MENSAJE DEL USUARIO: {message}
            
            Responde como InfoBot de GRUPO INFOTEC:
            """
            
            response = self.model.generate_content(prompt)
            return response.text.strip()
            
        except Exception as e:
            logger.error(f"Error generando respuesta general: {e}")
            return "¬°Hola! Soy InfoBot de GRUPO INFOTEC ü§ñ. Estoy aqu√≠ para ayudarte con informaci√≥n sobre nuestros productos, servicios t√©cnicos y m√°s. ¬øEn qu√© puedo asistirte hoy?"

    def get_conversation_history(self, session_id: str) -> List[Dict[str, Any]]:
        """Obtener historial de conversaci√≥n para una sesi√≥n espec√≠fica"""
        return self.session_conversations.get(session_id, [])

    def save_conversation(self, session_id: str, user_message: str, bot_response: str, 
                         intent: str, entities: Dict[str, Any], products_shown: bool = False) -> None:
        """Guardar conversaci√≥n en el historial"""
        if session_id not in self.session_conversations:
            self.session_conversations[session_id] = []
        
        conversation_entry = {
            "timestamp": datetime.now().isoformat(),
            "user_message": user_message,
            "bot_response": bot_response,
            "intent": intent,
            "entities": entities,
            "showed_products": products_shown
        }
        
        self.session_conversations[session_id].append(conversation_entry)
        
        # Mantener solo las √∫ltimas 10 conversaciones
        if len(self.session_conversations[session_id]) > 10:
            self.session_conversations[session_id] = self.session_conversations[session_id][-10:]

    def process_message(self, message: str, db: Session, user_id: Optional[int] = None, 
                       session_id: str = "default") -> Dict[str, Any]:
        """Procesar mensaje del usuario - MEJORADO con mejor error handling"""
        try:
            # Validar entrada
            if not message or not message.strip():
                return {
                    "response": "¬°Hola! Soy InfoBot de GRUPO INFOTEC ü§ñ. ¬øEn qu√© puedo ayudarte hoy?",
                    "intent": "saludo",
                    "entities": {},
                    "products": [],
                    "conversation_id": session_id
                }
            
            # Obtener historial de conversaci√≥n
            conversation_history = self.get_conversation_history(session_id)
            
            # Extraer entidades del mensaje
            entities = self.extract_entities(message)
              # Determinar si debe mostrar productos
            should_search = self.should_show_products(entities, conversation_history)
            
            intent = "buscar_producto" if should_search else "conversacion_general"
            products = []
            bot_response = ""
            
            if should_search:
                # Manejar acciones espec√≠ficas primero
                if entities.get("accion") == "ver_especificaciones":
                    # Si pide especificaciones, buscar producto espec√≠fico
                    if entities.get("producto_especifico"):
                        product = self.find_product_by_name(db, entities["producto_especifico"])
                        if product:
                            bot_response = self.generate_product_specifications(product)
                            products = [product]
                        else:
                            bot_response = f"No encontr√© informaci√≥n espec√≠fica sobre '{entities['producto_especifico']}'. ¬øPodr√≠as ser m√°s espec√≠fico con el modelo?"
                    else:
                        bot_response = "¬øSobre qu√© producto espec√≠fico te gustar√≠a conocer las especificaciones? Puedes mencionar el modelo exacto."
                
                elif entities.get("accion") == "agregar_carrito":
                    # Si quiere agregar al carrito, buscar producto espec√≠fico
                    if entities.get("producto_especifico"):
                        product = self.find_product_by_name(db, entities["producto_especifico"])
                        if product:
                            quantity = entities.get("cantidad", 1)
                            success = self.add_to_cart(db, product.id, quantity, user_id, session_id)
                            if success:
                                bot_response = f"‚úÖ ¬°Perfecto! He agregado **{product.name}** a tu carrito.\n\n"
                                bot_response += f"üì¶ **Cantidad:** {quantity}\n"
                                bot_response += f"üí∞ **Precio:** S/ {product.price:.2f}\n"
                                bot_response += f"üí≥ **Total:** S/ {product.price * quantity:.2f}\n\n"
                                bot_response += "¬øTe gustar√≠a agregar algo m√°s o proceder con la compra?"
                            else:
                                bot_response = f"‚ùå Lo siento, no pude agregar **{product.name}** al carrito. Podr√≠a estar agotado o no tener suficiente stock."
                            products = [product]
                        else:
                            bot_response = f"No encontr√© el producto '{entities['producto_especifico']}' en nuestro inventario. ¬øPodr√≠as verificar el nombre del modelo?"
                    else:
                        # Buscar productos para que elija cu√°l agregar
                        search_query = self.get_search_query_from_context(entities, conversation_history)
                        products = self.search_products(db, search_query, max_price=entities.get("presupuesto"))
                        
                        if products:
                            bot_response = "¬øCu√°l de estos productos te gustar√≠a agregar al carrito? Solo menciona el nombre espec√≠fico:\n\n"
                            bot_response += self.generate_product_response(products)
                        else:
                            bot_response = "No encontr√© productos disponibles que coincidan con tu b√∫squeda. ¬øPodr√≠as ser m√°s espec√≠fico?"
                
                else:
                    # B√∫squeda normal de productos
                    search_query = self.get_search_query_from_context(entities, conversation_history)
                    products = self.search_products(
                        db, 
                        search_query,
                        max_price=entities.get("presupuesto")
                    )
                    
                    if products:
                        detected_use_case = entities.get("uso")
                        bot_response = self.generate_product_response(products, detected_use_case)
                    else:
                        # Fallback: buscar productos generales
                        fallback_products = self.search_products(db, "laptop")
                        if fallback_products:
                            products = fallback_products[:5]
                            bot_response = "No encontr√© exactamente lo que buscas, pero aqu√≠ tienes algunas opciones populares que podr√≠an interesarte:\n\n"
                            bot_response += self.generate_product_response(products)
                        else:
                            bot_response = "Por el momento no tenemos productos disponibles en nuestro inventario. Te sugerimos contactarnos directamente para consultar disponibilidad. üìû"
            else:
                # Respuesta general
                context_str = ""
                if conversation_history:
                    recent_context = conversation_history[-2:]
                    context_str = "Conversaci√≥n previa: " + " | ".join([
                        f"Usuario: {conv['user_message'][:50]} -> Bot: {conv['bot_response'][:50]}" 
                        for conv in recent_context
                    ])
                
                bot_response = self.generate_general_response(message, context_str)
            
            # Guardar conversaci√≥n
            self.save_conversation(
                session_id, 
                message, 
                bot_response, 
                intent, 
                entities, 
                len(products) > 0
            )
            
            return {
                "response": bot_response,
                "intent": intent,
                "entities": entities,
                "products": [p.dict() for p in products] if products else [],
                "conversation_id": session_id
            }
            
        except Exception as e:
            logger.error(f"Error procesando mensaje: {e}")
            return {
                "response": "Disculpa, tuve un problema t√©cnico. ¬øPodr√≠as repetir tu mensaje? Estoy aqu√≠ para ayudarte ü§ñ",
                "intent": "error",                "entities": {},
                "products": [],
                "conversation_id": session_id
            }
